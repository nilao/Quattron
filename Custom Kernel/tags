!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CONFIG_I2C	HeadJ.h	4;"	d
DEBUG	main.c	/^void DEBUG(char *s,...){$/;"	f
DEG_TO_RAD	HeadJ.h	64;"	d
EMERGENCY	HeadJ.h	/^EMERGENCY = 0, \/\/system stop all motor init$/;"	e	enum:__anon2
FeedForward_function	HeadJ.c	/^uint32_t FeedForward_function(int m_val){$/;"	f
GPIO_DEV	HeadJ.h	191;"	d
GPIO_DIRECTION	gpio2_ioctl.h	83;"	d
GPIO_INPUT	gpio2_ioctl.h	/^	GPIO_INPUT = 0,				\/\/!< Pin configured for input$/;"	e	enum:gpio_mode
GPIO_IRQ_FREE	gpio2_ioctl.h	101;"	d
GPIO_IRQ_INIT	gpio2_ioctl.h	100;"	d
GPIO_IRQ_TYPE_EDGE_BOTH	gpio2_ioctl.h	/^	GPIO_IRQ_TYPE_EDGE_BOTH = 2,$/;"	e	enum:gpio_irq_mode
GPIO_IRQ_TYPE_EDGE_FALLING	gpio2_ioctl.h	/^	GPIO_IRQ_TYPE_EDGE_FALLING = 1,$/;"	e	enum:gpio_irq_mode
GPIO_IRQ_TYPE_EDGE_RISING	gpio2_ioctl.h	/^	GPIO_IRQ_TYPE_EDGE_RISING = 0,$/;"	e	enum:gpio_irq_mode
GPIO_IRQ_TYPE_LEVEL_HIGH	gpio2_ioctl.h	/^	GPIO_IRQ_TYPE_LEVEL_HIGH = 3,$/;"	e	enum:gpio_irq_mode
GPIO_IRQ_TYPE_LEVEL_LOW	gpio2_ioctl.h	/^	GPIO_IRQ_TYPE_LEVEL_LOW = 4,$/;"	e	enum:gpio_irq_mode
GPIO_IRQ_WAIT	gpio2_ioctl.h	102;"	d
GPIO_MAGIC	gpio2_ioctl.h	76;"	d
GPIO_OUTPUT_HIGH	gpio2_ioctl.h	/^	GPIO_OUTPUT_HIGH,			\/\/!< Pin configured for output with high level$/;"	e	enum:gpio_mode
GPIO_OUTPUT_LOW	gpio2_ioctl.h	/^	GPIO_OUTPUT_LOW,			\/\/!< Pin configured for output with low level$/;"	e	enum:gpio_mode
GPIO_READ	gpio2_ioctl.h	90;"	d
GPIO_WRITE	gpio2_ioctl.h	99;"	d
GRAVITY	main.c	66;"	d	file:
GpioDir	HeadJ.c	/^void GpioDir(int pin,enum gpio_mode mode){$/;"	f
GpioOpen	HeadJ.c	/^void GpioOpen(){$/;"	f
GpioWrite	HeadJ.c	/^void GpioWrite(int pin, int value){$/;"	f
KalmanInit	KalmanJ.c	/^void KalmanInit(Kalman_t *kal) {$/;"	f
Kalman_t	KalmanJ.h	/^typedef struct Kalman_t{$/;"	s
Kalman_t	KalmanJ.h	/^}Kalman_t;$/;"	t	typeref:struct:Kalman_t
KalmangetAngle	KalmanJ.c	/^float KalmangetAngle(Kalman_t *kal, float newAngle, float newRate, float dt) {$/;"	f
KalmangetQangle	KalmanJ.c	/^float KalmangetQangle(Kalman_t *kal) { return kal->Q_angle; };$/;"	f
KalmangetQbias	KalmanJ.c	/^float KalmangetQbias(Kalman_t *kal) { return kal->Q_bias; };$/;"	f
KalmangetRate	KalmanJ.c	/^float KalmangetRate(Kalman_t *kal) { return kal->rate; }; \/\/ Return the unbiased rate$/;"	f
KalmangetRmeasure	KalmanJ.c	/^float KalmangetRmeasure(Kalman_t *kal) { return kal->R_measure; };$/;"	f
KalmansetAngle	KalmanJ.c	/^void KalmansetAngle(Kalman_t *kal, float angle) { kal->angle = angle; }; \/\/ Used to set angle, this should be set as the starting angle$/;"	f
KalmansetQangle	KalmanJ.c	/^void KalmansetQangle(Kalman_t *kal,float Q_angle) { kal->Q_angle = Q_angle; };$/;"	f
KalmansetQbias	KalmanJ.c	/^void KalmansetQbias(Kalman_t *kal,float Q_bias) { kal->Q_bias = Q_bias; };$/;"	f
KalmansetRmeasure	KalmanJ.c	/^void KalmansetRmeasure(Kalman_t *kal,float R_measure) { kal->R_measure = R_measure; };$/;"	f
Kd	HeadJ.h	/^	Kd,$/;"	e	enum:__anon5
Ki	HeadJ.h	/^	Ki,$/;"	e	enum:__anon5
Kp	HeadJ.h	/^	Kp=0,$/;"	e	enum:__anon5
LDByteWriteI2C	HeadJ.c	/^void LDByteWriteI2C(int fd, uint8_t address, uint8_t value)$/;"	f
LED_GREEN_LEFT	HeadJ.h	189;"	d
LED_GREEN_RIGHT	HeadJ.h	188;"	d
LED_RED_LEFT	HeadJ.h	187;"	d
LED_RED_RIGHT	HeadJ.h	186;"	d
MAHONY	HeadJ.h	/^MAHONY = 5,$/;"	e	enum:__anon2
MEM_R_W	mpu6050.c	6;"	d	file:
MEM_START_ADDR	mpu6050.c	5;"	d	file:
MOTOR_ENUM	HeadJ.h	/^}MOTOR_ENUM;$/;"	t	typeref:enum:__anon5
MOTOR_SYSTEM_NUM	HeadJ.h	200;"	d
MPU6050_ADDRESS	HeadJ.h	68;"	d
MPU6050_RA_ACCEL_CONFIG	HeadJ.h	90;"	d
MPU6050_RA_ACCEL_XOUT_H	HeadJ.h	121;"	d
MPU6050_RA_ACCEL_XOUT_L	HeadJ.h	122;"	d
MPU6050_RA_ACCEL_YOUT_H	HeadJ.h	123;"	d
MPU6050_RA_ACCEL_YOUT_L	HeadJ.h	124;"	d
MPU6050_RA_ACCEL_ZOUT_H	HeadJ.h	125;"	d
MPU6050_RA_ACCEL_ZOUT_L	HeadJ.h	126;"	d
MPU6050_RA_BANK_SEL	HeadJ.h	170;"	d
MPU6050_RA_CONFIG	HeadJ.h	88;"	d
MPU6050_RA_DMP_CFG_1	HeadJ.h	173;"	d
MPU6050_RA_DMP_CFG_2	HeadJ.h	174;"	d
MPU6050_RA_DMP_INT_STATUS	HeadJ.h	119;"	d
MPU6050_RA_EXT_SENS_DATA_00	HeadJ.h	135;"	d
MPU6050_RA_EXT_SENS_DATA_01	HeadJ.h	136;"	d
MPU6050_RA_EXT_SENS_DATA_02	HeadJ.h	137;"	d
MPU6050_RA_EXT_SENS_DATA_03	HeadJ.h	138;"	d
MPU6050_RA_EXT_SENS_DATA_04	HeadJ.h	139;"	d
MPU6050_RA_EXT_SENS_DATA_05	HeadJ.h	140;"	d
MPU6050_RA_EXT_SENS_DATA_06	HeadJ.h	141;"	d
MPU6050_RA_EXT_SENS_DATA_07	HeadJ.h	142;"	d
MPU6050_RA_EXT_SENS_DATA_08	HeadJ.h	143;"	d
MPU6050_RA_EXT_SENS_DATA_09	HeadJ.h	144;"	d
MPU6050_RA_EXT_SENS_DATA_10	HeadJ.h	145;"	d
MPU6050_RA_EXT_SENS_DATA_11	HeadJ.h	146;"	d
MPU6050_RA_EXT_SENS_DATA_12	HeadJ.h	147;"	d
MPU6050_RA_EXT_SENS_DATA_13	HeadJ.h	148;"	d
MPU6050_RA_EXT_SENS_DATA_14	HeadJ.h	149;"	d
MPU6050_RA_EXT_SENS_DATA_15	HeadJ.h	150;"	d
MPU6050_RA_EXT_SENS_DATA_16	HeadJ.h	151;"	d
MPU6050_RA_EXT_SENS_DATA_17	HeadJ.h	152;"	d
MPU6050_RA_EXT_SENS_DATA_18	HeadJ.h	153;"	d
MPU6050_RA_EXT_SENS_DATA_19	HeadJ.h	154;"	d
MPU6050_RA_EXT_SENS_DATA_20	HeadJ.h	155;"	d
MPU6050_RA_EXT_SENS_DATA_21	HeadJ.h	156;"	d
MPU6050_RA_EXT_SENS_DATA_22	HeadJ.h	157;"	d
MPU6050_RA_EXT_SENS_DATA_23	HeadJ.h	158;"	d
MPU6050_RA_FF_DUR	HeadJ.h	92;"	d
MPU6050_RA_FF_THR	HeadJ.h	91;"	d
MPU6050_RA_FIFO_COUNTH	HeadJ.h	175;"	d
MPU6050_RA_FIFO_COUNTL	HeadJ.h	176;"	d
MPU6050_RA_FIFO_EN	HeadJ.h	97;"	d
MPU6050_RA_FIFO_R_W	HeadJ.h	177;"	d
MPU6050_RA_GYRO_CONFIG	HeadJ.h	89;"	d
MPU6050_RA_GYRO_XOUT_H	HeadJ.h	129;"	d
MPU6050_RA_GYRO_XOUT_L	HeadJ.h	130;"	d
MPU6050_RA_GYRO_YOUT_H	HeadJ.h	131;"	d
MPU6050_RA_GYRO_YOUT_L	HeadJ.h	132;"	d
MPU6050_RA_GYRO_ZOUT_H	HeadJ.h	133;"	d
MPU6050_RA_GYRO_ZOUT_L	HeadJ.h	134;"	d
MPU6050_RA_I2C_MST_CTRL	HeadJ.h	98;"	d
MPU6050_RA_I2C_MST_DELAY_CTRL	HeadJ.h	164;"	d
MPU6050_RA_I2C_MST_STATUS	HeadJ.h	116;"	d
MPU6050_RA_I2C_SLV0_ADDR	HeadJ.h	99;"	d
MPU6050_RA_I2C_SLV0_CTRL	HeadJ.h	101;"	d
MPU6050_RA_I2C_SLV0_DO	HeadJ.h	160;"	d
MPU6050_RA_I2C_SLV0_REG	HeadJ.h	100;"	d
MPU6050_RA_I2C_SLV1_ADDR	HeadJ.h	102;"	d
MPU6050_RA_I2C_SLV1_CTRL	HeadJ.h	104;"	d
MPU6050_RA_I2C_SLV1_DO	HeadJ.h	161;"	d
MPU6050_RA_I2C_SLV1_REG	HeadJ.h	103;"	d
MPU6050_RA_I2C_SLV2_ADDR	HeadJ.h	105;"	d
MPU6050_RA_I2C_SLV2_CTRL	HeadJ.h	107;"	d
MPU6050_RA_I2C_SLV2_DO	HeadJ.h	162;"	d
MPU6050_RA_I2C_SLV2_REG	HeadJ.h	106;"	d
MPU6050_RA_I2C_SLV3_ADDR	HeadJ.h	108;"	d
MPU6050_RA_I2C_SLV3_CTRL	HeadJ.h	110;"	d
MPU6050_RA_I2C_SLV3_DO	HeadJ.h	163;"	d
MPU6050_RA_I2C_SLV3_REG	HeadJ.h	109;"	d
MPU6050_RA_I2C_SLV4_ADDR	HeadJ.h	111;"	d
MPU6050_RA_I2C_SLV4_CTRL	HeadJ.h	114;"	d
MPU6050_RA_I2C_SLV4_DI	HeadJ.h	115;"	d
MPU6050_RA_I2C_SLV4_DO	HeadJ.h	113;"	d
MPU6050_RA_I2C_SLV4_REG	HeadJ.h	112;"	d
MPU6050_RA_INT_ENABLE	HeadJ.h	118;"	d
MPU6050_RA_INT_PIN_CFG	HeadJ.h	117;"	d
MPU6050_RA_INT_STATUS	HeadJ.h	120;"	d
MPU6050_RA_MEM_R_W	HeadJ.h	172;"	d
MPU6050_RA_MEM_START_ADDR	HeadJ.h	171;"	d
MPU6050_RA_MOT_DETECT_CTRL	HeadJ.h	166;"	d
MPU6050_RA_MOT_DETECT_STATUS	HeadJ.h	159;"	d
MPU6050_RA_MOT_DUR	HeadJ.h	94;"	d
MPU6050_RA_MOT_THR	HeadJ.h	93;"	d
MPU6050_RA_PWR_MGMT_1	HeadJ.h	168;"	d
MPU6050_RA_PWR_MGMT_2	HeadJ.h	169;"	d
MPU6050_RA_SIGNAL_PATH_RESET	HeadJ.h	165;"	d
MPU6050_RA_SMPLRT_DIV	HeadJ.h	87;"	d
MPU6050_RA_TEMP_OUT_H	HeadJ.h	127;"	d
MPU6050_RA_TEMP_OUT_L	HeadJ.h	128;"	d
MPU6050_RA_USER_CTRL	HeadJ.h	167;"	d
MPU6050_RA_WHO_AM_I	HeadJ.h	178;"	d
MPU6050_RA_XA_OFFS_H	HeadJ.h	75;"	d
MPU6050_RA_XA_OFFS_L_TC	HeadJ.h	76;"	d
MPU6050_RA_XG_OFFS_TC	HeadJ.h	69;"	d
MPU6050_RA_XG_OFFS_USRH	HeadJ.h	81;"	d
MPU6050_RA_XG_OFFS_USRL	HeadJ.h	82;"	d
MPU6050_RA_X_FINE_GAIN	HeadJ.h	72;"	d
MPU6050_RA_YA_OFFS_H	HeadJ.h	77;"	d
MPU6050_RA_YA_OFFS_L_TC	HeadJ.h	78;"	d
MPU6050_RA_YG_OFFS_TC	HeadJ.h	70;"	d
MPU6050_RA_YG_OFFS_USRH	HeadJ.h	83;"	d
MPU6050_RA_YG_OFFS_USRL	HeadJ.h	84;"	d
MPU6050_RA_Y_FINE_GAIN	HeadJ.h	73;"	d
MPU6050_RA_ZA_OFFS_H	HeadJ.h	79;"	d
MPU6050_RA_ZA_OFFS_L_TC	HeadJ.h	80;"	d
MPU6050_RA_ZG_OFFS_TC	HeadJ.h	71;"	d
MPU6050_RA_ZG_OFFS_USRH	HeadJ.h	85;"	d
MPU6050_RA_ZG_OFFS_USRL	HeadJ.h	86;"	d
MPU6050_RA_ZRMOT_DUR	HeadJ.h	96;"	d
MPU6050_RA_ZRMOT_THR	HeadJ.h	95;"	d
MPU6050_RA_Z_FINE_GAIN	HeadJ.h	74;"	d
MPU6050_init	mpu6050.c	/^void MPU6050_init(){$/;"	f
MPU_ADDR	mpu6050.c	4;"	d	file:
MPU_AFS4G	HeadJ.h	67;"	d
MPU_AFSSEL	HeadJ.h	66;"	d
MPU_OFFSET	HeadJ.h	65;"	d
MahonyAHRS_h	MahonyAHRS.h	14;"	d
MahonyAHRSupdate	MahonyAHRS.c	/^void MahonyAHRSupdate(float gx, float gy, float gz, float ax, float ay, float az, float mx, float my, float mz) {$/;"	f
MahonyAHRSupdateIMU	MahonyAHRS.c	/^void MahonyAHRSupdateIMU(float gx, float gy, float gz, float ax, float ay, float az) {$/;"	f
MotorControl	HeadJ.c	/^int MotorControl(sensor_t ro, sensor_t pit,int thrott[] ){$/;"	f
P	KalmanJ.h	/^    float P[2][2]; \/\/ Error covariance matrix - This is a 2x2 matrix$/;"	m	struct:Kalman_t
PITCH	HeadJ.h	/^	PITCH,$/;"	e	enum:__anon4
PWM_DELOS_REQUEST	pwm_ioctl.h	115;"	d
PWM_DELOS_SET_CTRL	pwm_ioctl.h	114;"	d
PWM_DELOS_SET_RATIOS	pwm_ioctl.h	112;"	d
PWM_DELOS_SET_SPEEDS	pwm_ioctl.h	113;"	d
PWM_DEV	HeadJ.h	190;"	d
PWM_GET_FREQ	pwm_ioctl.h	91;"	d
PWM_GET_WIDTH	pwm_ioctl.h	107;"	d
PWM_GET_WIDTH_8BITS_RATIO_MODE	pwm_ioctl.h	123;"	d
PWM_MAGIC	pwm_ioctl.h	39;"	d
PWM_MAX	pwm_ioctl.h	44;"	d
PWM_RELEASE	pwm_ioctl.h	62;"	d
PWM_REQUEST	pwm_ioctl.h	56;"	d
PWM_SET_FREQ	pwm_ioctl.h	84;"	d
PWM_SET_FREQ_8BITS_RATIO_MODE	pwm_ioctl.h	121;"	d
PWM_SET_WIDTH	pwm_ioctl.h	100;"	d
PWM_SET_WIDTH_8BITS_RATIO_MODE	pwm_ioctl.h	122;"	d
PWM_START	pwm_ioctl.h	69;"	d
PWM_STOP	pwm_ioctl.h	76;"	d
PWM_WIDTH_8BITS_RATIO_MODE_MAX	pwm_ioctl.h	119;"	d
PWM_WIDTH_MAX	pwm_ioctl.h	93;"	d
Pitch_m	main.c	/^float Yaw_m,Pitch_m,Roll_m;$/;"	v
PwmInit	HeadJ.c	/^int PwmInit(){$/;"	f
PwmSetWidth	HeadJ.c	/^int PwmSetWidth(unsigned int pwm,unsigned int width ){$/;"	f
Q_angle	KalmanJ.h	/^    float Q_angle; \/\/ Process noise variance for the accelerometer$/;"	m	struct:Kalman_t
Q_bias	KalmanJ.h	/^    float Q_bias; \/\/ Process noise variance for the gyro bias$/;"	m	struct:Kalman_t
RAD_TO_DEG	HeadJ.h	63;"	d
ROLL	HeadJ.h	/^	ROLL,$/;"	e	enum:__anon4
R_measure	KalmanJ.h	/^    float R_measure; \/\/ Measurement noise variance - this is actually the variance of the measurement noise$/;"	m	struct:Kalman_t
Roll_m	main.c	/^float Yaw_m,Pitch_m,Roll_m;$/;"	v
SENSRO_CMD	HeadJ.h	/^}SENSRO_CMD;$/;"	t	typeref:enum:__anon3
SYSTEM_CMD	HeadJ.h	/^}SYSTEM_CMD;$/;"	t	typeref:enum:__anon2
SYSTEM_KONST	HeadJ.h	/^SYSTEM_KONST = 2,\/\/ input = sys Kp Ki Kd $/;"	e	enum:__anon2
S_ACCEL	HeadJ.h	/^S_ACCEL=0,$/;"	e	enum:__anon3
S_COMPLEMENTARY	HeadJ.h	/^S_COMPLEMENTARY = 3,$/;"	e	enum:__anon3
S_GYRO	HeadJ.h	/^S_GYRO=1,$/;"	e	enum:__anon3
S_INTEGRAL	HeadJ.h	/^S_INTEGRAL,$/;"	e	enum:__anon3
S_KALMAN	HeadJ.h	/^S_KALMAN = 2 ,\/\/ motor value 0 1 2 3 input$/;"	e	enum:__anon3
S_NEW	HeadJ.h	/^S_NEW,$/;"	e	enum:__anon3
S_QUAT	HeadJ.h	/^S_QUAT,$/;"	e	enum:__anon3
S_QUAT_TO_EULER	HeadJ.h	/^S_QUAT_TO_EULER,$/;"	e	enum:__anon3
SensorInit	HeadJ.c	/^int SensorInit(){$/;"	f
SensorInit_MPU	HeadJ.c	/^int SensorInit_MPU(){$/;"	f
SensorKalmanFilter	HeadJ.c	/^int SensorKalmanFilter(){$/;"	f
SensorRead	HeadJ.c	/^int SensorRead(){$/;"	f
SensorReadTrig	HeadJ.c	/^int SensorReadTrig(){$/;"	f
TAKEOFF	HeadJ.h	/^TAKEOFF = 1, \/\/ start timer and motor and pid$/;"	e	enum:__anon2
TF_function	HeadJ.c	/^int TF_function(TF_t t ,motor_t val){$/;"	f
TF_t	HeadJ.h	/^}TF_t;$/;"	t	typeref:enum:__anon4
THROTT_INPUT	HeadJ.h	/^THROTT_INPUT = 3,$/;"	e	enum:__anon2
TIMER_EMER	main.c	/^int TIMER_EMER =1;$/;"	v
TOTAL_SENSOR	HeadJ.h	/^TOTAL_SENSOR = 4,$/;"	e	enum:__anon2
TimerWait	main.c	/^int TimerWait(){$/;"	f
TimerWorking	main.c	/^int TimerWorking(long nperiod, long nendtime){\/\/if endtime == 0 then infinite  wait for timer $/;"	f
WEIGHT	HeadJ.h	201;"	d
Yaw_m	main.c	/^float Yaw_m,Pitch_m,Roll_m;$/;"	v
_GPIO_IOCTL_H	gpio2_ioctl.h	43;"	d
_HeadJ_h_	HeadJ.h	3;"	d
_Kalman_h_	KalmanJ.h	19;"	d
_PWM_IOCTL_H	pwm_ioctl.h	35;"	d
accX	HeadJ.c	/^int16_t accX, accY, accZ;$/;"	v
accY	HeadJ.c	/^int16_t accX, accY, accZ;$/;"	v
accZ	HeadJ.c	/^int16_t accX, accY, accZ;$/;"	v
angle	KalmanJ.h	/^    float angle; \/\/ The angle calculated by the Kalman filter - part of the 2x1 state vector$/;"	m	struct:Kalman_t
bank_sel	mpu6050.c	/^void bank_sel(uint8_t bank){$/;"	f
bias	KalmanJ.h	/^    float bias; \/\/ The gyro bias calculated by the Kalman filter - part of the 2x1 state vector$/;"	m	struct:Kalman_t
buf	HeadJ.c	/^char buf[40];$/;"	v
check_MPU	mpu6050.c	/^void check_MPU(){$/;"	f
cnt	HeadJ.c	/^uint32_t cnt=0;$/;"	v
compAngleX	HeadJ.c	/^sensor_t compAngleX, compAngleY; \/\/ Calculated angle using a complementary filter$/;"	v
compAngleY	HeadJ.c	/^sensor_t compAngleX, compAngleY; \/\/ Calculated angle using a complementary filter$/;"	v
cond	main.c	/^pthread_cond_t cond = PTHREAD_COND_INITIALIZER;$/;"	v
dmpMem	mpu6050.c	/^unsigned char dmpMem[8][16][16] = {$/;"	v
dmp_init	mpu6050.c	/^void dmp_init(){$/;"	f
dmp_updates	mpu6050.c	/^static uint8_t dmp_updates[29][9] =$/;"	v	file:
dt	HeadJ.h	35;"	d
errD_prev	HeadJ.h	/^	errD_prev$/;"	e	enum:__anon5
errI	HeadJ.h	/^	errI,$/;"	e	enum:__anon5
err_prev	HeadJ.h	/^	err_prev,$/;"	e	enum:__anon5
fd_gpio	HeadJ.c	/^int fd_gpio;$/;"	v
fd_pwm	HeadJ.c	/^int fd_pwm;$/;"	v
fd_sensor	HeadJ.c	/^int fd_sensor;$/;"	v
fifoCountL	mpu6050.c	/^uint8_t fifoCountL = 0;$/;"	v
fifoCountL2	mpu6050.c	/^uint8_t fifoCountL2 = 0;$/;"	v
fifoReady	mpu6050.c	/^uint8_t fifoReady(){$/;"	f
firstPacket	mpu6050.c	/^uint8_t firstPacket = true;$/;"	v
getPacket	mpu6050.c	/^void getPacket(){$/;"	f
gmutex	main.c	/^pthread_mutex_t  gmutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
gpio_data	gpio2_ioctl.h	/^struct gpio_data {$/;"	s
gpio_direction	gpio2_ioctl.h	/^struct gpio_direction {$/;"	s
gpio_irq	gpio2_ioctl.h	/^struct gpio_irq {$/;"	s
gpio_irq_mode	gpio2_ioctl.h	/^enum gpio_irq_mode {$/;"	g
gpio_mode	gpio2_ioctl.h	/^enum gpio_mode {$/;"	g
gyroX	HeadJ.c	/^int16_t gyroX, gyroY, gyroZ;$/;"	v
gyroXangle	HeadJ.c	/^sensor_t gyroXangle, gyroYangle; \/\/ Angle calculate using the gyro only$/;"	v
gyroY	HeadJ.c	/^int16_t gyroX, gyroY, gyroZ;$/;"	v
gyroYangle	HeadJ.c	/^sensor_t gyroXangle, gyroYangle; \/\/ Angle calculate using the gyro only$/;"	v
gyroZ	HeadJ.c	/^int16_t gyroX, gyroY, gyroZ;$/;"	v
hr_timer	time.c	/^struct hrtimer hr_timer;$/;"	v	typeref:struct:hrtimer
integralFBx	MahonyAHRS.c	/^volatile float integralFBx = 0.0f,  integralFBy = 0.0f, integralFBz = 0.0f;	\/\/ integral error terms scaled by Ki$/;"	v
integralFBy	MahonyAHRS.c	/^volatile float integralFBx = 0.0f,  integralFBy = 0.0f, integralFBz = 0.0f;	\/\/ integral error terms scaled by Ki$/;"	v
integralFBz	MahonyAHRS.c	/^volatile float integralFBx = 0.0f,  integralFBy = 0.0f, integralFBz = 0.0f;	\/\/ integral error terms scaled by Ki$/;"	v
invSqrt	MahonyAHRS.c	/^float invSqrt(float x) {$/;"	f
kalAngleX	HeadJ.c	/^sensor_t kalAngleX, kalAngleY; \/\/ Calculated angle using a Kalman filter$/;"	v
kalAngleY	HeadJ.c	/^sensor_t kalAngleX, kalAngleY; \/\/ Calculated angle using a Kalman filter$/;"	v
kalmanX	HeadJ.c	/^Kalman_t kalmanX; \/\/ Create the Kalman instances$/;"	v
kalmanY	HeadJ.c	/^Kalman_t kalmanY;$/;"	v
lastRead	mpu6050.c	/^int lastRead = 0;$/;"	v
longPacket	mpu6050.c	/^uint8_t longPacket = false;$/;"	v
loop	mpu6050.c	/^void loop(){$/;"	f
main	main.c	/^int main(){$/;"	f
main	time.c	/^int main(){$/;"	f
main_control_code	main.c	/^void main_control_code  (int signum)$/;"	f
mask_bit	main.c	/^uint32_t mask_bit =0;$/;"	v
mconst	HeadJ.c	/^motor_t mconst[2][10];$/;"	v
mem_init	mpu6050.c	/^void mem_init(){$/;"	f
mode	gpio2_ioctl.h	/^	enum gpio_irq_mode mode;$/;"	m	struct:gpio_irq	typeref:enum:gpio_irq::gpio_irq_mode
mode	gpio2_ioctl.h	/^	enum gpio_mode mode;$/;"	m	struct:gpio_direction	typeref:enum:gpio_direction::gpio_mode
motor_t	HeadJ.h	/^typedef float motor_t;$/;"	t
mutex	main.c	/^pthread_mutex_t  mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
my_hrtimer_callback	time.c	/^enum hrtimer_restart my_hrtimer_callback( struct hrtimer *timer )$/;"	f
new_pitch	main.c	/^sensor_t new_pitch=0;$/;"	v
new_roll	main.c	/^sensor_t new_roll=0;$/;"	v
new_yaw	main.c	/^sensor_t new_yaw=0;$/;"	v
packetCount	mpu6050.c	/^uint8_t packetCount = 0x00;$/;"	v
pin	gpio2_ioctl.h	/^	int pin;$/;"	m	struct:gpio_data
pin	gpio2_ioctl.h	/^	int pin;$/;"	m	struct:gpio_direction
pin	gpio2_ioctl.h	/^	int pin;$/;"	m	struct:gpio_irq
pitch	HeadJ.c	/^sensor_t roll,pitch;$/;"	v
processQuat	mpu6050.c	/^void processQuat(){$/;"	f
processed_packet	mpu6050.c	/^uint8_t processed_packet[8];$/;"	v
pwm_delos_quadruplet	pwm_ioctl.h	/^typedef struct { unsigned int val[4]; } __attribute__ ((packed)) pwm_delos_quadruplet;$/;"	t	typeref:struct:__anon1
q0	MahonyAHRS.c	/^volatile float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f;					\/\/ quaternion of sensor frame relative to auxiliary frame$/;"	v
q1	MahonyAHRS.c	/^volatile float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f;					\/\/ quaternion of sensor frame relative to auxiliary frame$/;"	v
q2	MahonyAHRS.c	/^volatile float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f;					\/\/ quaternion of sensor frame relative to auxiliary frame$/;"	v
q3	MahonyAHRS.c	/^volatile float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f;					\/\/ quaternion of sensor frame relative to auxiliary frame$/;"	v
quat_to_euler	main.c	/^void quat_to_euler(float *ro,float* pit, float* ya ){$/;"	f
rate	KalmanJ.h	/^    float rate; \/\/ Unbiased rate calculated from the rate and the calculated bias - you have to call getAngle to update the rate$/;"	m	struct:Kalman_t
read_i2c	HeadJ.c	/^int read_i2c(int dev_num, char *data, int size, int offset)$/;"	f
read_interrupt	mpu6050.c	/^uint8_t read_interrupt(){$/;"	f
received_packet	mpu6050.c	/^uint8_t received_packet[50];$/;"	v
regRead	mpu6050.c	/^uint8_t regRead(uint8_t reg){$/;"	f
regWrite	mpu6050.c	/^void regWrite(uint8_t reg ,uint8_t data){$/;"	f
resetFifo	mpu6050.c	/^void resetFifo(){$/;"	f
roll	HeadJ.c	/^sensor_t roll,pitch;$/;"	v
sampleFreq	MahonyAHRS.c	23;"	d	file:
sendHeader	mpu6050.c	/^void sendHeader(){$/;"	f
sendPacket	mpu6050.c	/^void sendPacket(){$/;"	f
sendQuat	mpu6050.c	/^void sendQuat(){$/;"	f
sensor_t	HeadJ.h	/^typedef float sensor_t;$/;"	t
set	main.c	/^sigset_t set;$/;"	v
t_function	main.c	/^void *t_function(void *data){$/;"	f
t_motor	main.c	/^void *t_motor(void *data){$/;"	f
t_readsensor	main.c	/^void *t_readsensor(void *data){$/;"	f
target	HeadJ.c	/^motor_t target[2];$/;"	v
temp	mpu6050.c	/^uint8_t temp = 0;$/;"	v
temper	HeadJ.c	/^uint16_t temper;$/;"	v
thrott	main.c	/^int  thrott[4];$/;"	v
timer1	main.c	/^timer_t timer1;$/;"	v
twoKi	MahonyAHRS.c	/^volatile float twoKi = twoKiDef;											\/\/ 2 * integral gain (Ki)$/;"	v
twoKiDef	MahonyAHRS.c	25;"	d	file:
twoKp	MahonyAHRS.c	/^volatile float twoKp = twoKpDef;											\/\/ 2 * proportional gain (Kp)$/;"	v
twoKpDef	MahonyAHRS.c	24;"	d	file:
val	pwm_ioctl.h	/^typedef struct { unsigned int val[4]; } __attribute__ ((packed)) pwm_delos_quadruplet;$/;"	m	struct:__anon1
value	gpio2_ioctl.h	/^	int value;$/;"	m	struct:gpio_data
write_i2c	HeadJ.c	/^int write_i2c(int dev_num, unsigned char *data, int size, int offset)$/;"	f
